Interrupt Collector by Eccelerators
===================================

.. contents:: 
   :depth: 2

Introduction
------------

The *Interrupt-Collector*, offered by Eccelerators, is a key IP block (Intellectual Property Block). 
Its main role is to aggregate interrupts from different sources and route them to the interrupt input of a CPU (Central Processing Unit) 
or a multiprocessor system. This functionality is crucial in complex environments where numerous devices or 
processes operate simultaneously, necessitating the CPU's attention.

Functionality
-------------

The distinctiveness of the Interrupt-Collector is evident in the type of interrupt sources it can manage. 
It is specifically designed for level-triggered interrupt sources, meaning the interrupt stays active as long as 
the trigger event or signal condition persists. This is in contrast to edge-triggered sources, which initiate an 
interrupt due to a change in the signal state, like transitioning from low to high or vice versa.

For systems employing edge-triggered sources, Eccelerators presents an additional solution â€“ the *Event-Catcher*. 
This IP block is capable of transforming edge-triggered sources into level-triggered sources, thereby ensuring 
compatibility with the Interrupt-Collector. 

The interrupt collector consists of two parts. The first part, the hardware-software interface, is generated by the Eccelerators Tool HxS. 
It uses the description of the Mask-, Service- and Request, Registers in the HxS language as input. The output is the complete implementation 
of these registers in VHDL, with the necessary inputs and outputs to a user logic block. 
The second part contains the logic of the interrupt collector function, coded by the user.

The design allows for the simultaneous processing of different interrupts within the same interrupt collector by multiple 
processors of a multiprocessor system, without the need for additional synchronization measures such as Spin-Locks.

The accompanying diagram illustrates the implementation, including the connection of the HxS block to a Wishbone bus leading 
to the CPU or the multiprocessor system. The User Block demonstrates the realization of the interrupt logic. 
Both blocks are scalable in terms of the number of serviced interrupt inputs.

.. figure:: hxs/resources/InterruptCollectorOverview.png
   :scale: 50
   
   Interrupt Collector Overview

Upon the arrival of an interrupt event at an input, an interrupt is triggered to the CPU system. 
This leads to the execution of an interrupt routine by software on exactly one CPU of the system. The routine reads the *Request-Register*
in the interrupt collector, selects one of the reported interrupt requests for processing, and acknowledges 
this by setting the corresponding bit in the Request-Register. 
This interrupt request is then reset in the Request-Register and appears in the *Service-Register*. After completing the tasks in the interrupt 
service routine, the CPU sets to the corresponding bit in the Service-Register, thereby signaling the end of the interrupt routine 
to the interrupt collector. Only from this point can the corresponding Request-Register bit be set again by the same interrupt input.

The actual triggering of an interrupt to the CPU system can be enabled or disabled in the *Mask-Register* for each input. 
After each acknowledged request, the interrupt line to the CPU system is briefly deactivated to allow for the processing 
of further interrupts by other CPUs of the system. 

The priority and synchrony of the individual interrupt inputs can be adjusted by the user in the User-Logic.

Testbench
---------


.. figure:: src/rst/resources/InterruptCollectorTestbench.png
   :scale: 50
   
   Interrupt Collector Testbench


Simulation
----------

In this article, we focussed on an individual IP component rather than a complete
FPGA design. Consequently, instead of creating a bitstream, we employ GHDL for
simulation purposes. Our IP is simulated using the SimStm framework, a tool we
developed for simulation and testing.

To begin with, we utilize the register description to generate various HxS artifacts,
including the VHDL register interface and its documentation. For this process,
we've set up a Linux environment, specifically using Ubuntu 22.04. The first step
involves installing Ant.

    ~$ sudo apt-get install ant -y

Next, we clone the actual `interrupt-collector <https://github.com/eccelerators/interrupt-collector/>`_.
repository:

    ~$ git clone --recurse-submodules git@github.com:eccelerators/crc-calculator.git

Following that, we establish a Python3 virtual environment and install the necessary
dependencies:

    ~$ python3 -m venv .venv
    ~$ source .venv/bin/activate
    ~$ pip3 install -r requirements.txt

With the setup complete, we are now ready to build all the artifacts required for
simulation:

    ~$ make

The HxS files are located in the `hxs` directory. The VHDL files related to the
IP and its simulation are organized within the following directory structure:

src/vhdl This folder contains the primary VHDL source files for the IP.
src-gen/vhdl Here, you'll find generated VHDL files specific to
  the AXI4-Lite interface.
tb/vhdl This directory houses the VHDL files used for testbenching and
  simulation.

Additionally, the documentation for this IP, generated in various formats, is
located in these folders:

src-gen/docbook-pdf Contains the documentation in PDF format.
src-gen/docbook-html  Holds the HTML version of the documentation (Docbook).
src-gen/html-sphinx  Holds the HTML version of the documentation (Sphinx).
src-gen/rst Stores the reStructuredText (rst) files, typically used for
  more textual documentation.

The simulation is executed with the following command:

    ~$ make sim

A successful simulation will yield an output similar to this:

    + ./crccalculatortestbench --stop-time=100000ns
    simstm/src/tb_simstm.vhd:1245:21:@1000300ps:(assertion note): test finished with no errors!!
    
    

Conclusion
----------

Overall, the Interrupt-Collector is a testament to the advanced technological 
strides in the realm of computer hardware, pivotal in crafting more efficient and adaptable 
computing systems. Such innovations are integral to the evolution of high-performance computing 
environments, particularly in sectors like server infrastructures, embedded systems, and intricate data processing units.



