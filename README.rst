Interrupt Collector by Eccelerators
===================================

.. contents:: 
   :depth: 3

Introduction
------------

The *Interrupt-Collector*, offered by Eccelerators, is a key IP block (Intellectual Property Block). 
Its main role is to aggregate interrupts from different sources and route them to the interrupt input of a CPU (Central Processing Unit) 
or a multiprocessor system. This functionality is crucial in complex environments where numerous devices or 
processes operate simultaneously, necessitating the CPU's attention.

Functionality
-------------

The distinctiveness of the Interrupt-Collector is evident in the type of interrupt sources it can manage. 
It is specifically designed for level-triggered interrupt sources, meaning the interrupt stays active as long as 
the trigger event or signal condition persists. This is in contrast to edge-triggered sources, which initiate an 
interrupt due to a change in the signal state, like transitioning from low to high or vice versa.

For systems employing edge-triggered sources, Eccelerators presents an additional solution â€“ the *Event-Catcher*. 
This IP block is capable of transforming edge-triggered sources into level-triggered sources, thereby ensuring 
compatibility with the Interrupt-Collector. 

The interrupt collector consists of two parts. The first part, the hardware-software interface, is generated by the Eccelerators Tool HxS. 
It uses the description of the Mask-, Service- and Request, Registers in the HxS language as input. The output is the complete implementation 
of these registers in VHDL, with the necessary inputs and outputs to a user logic block. 
The second part contains the logic of the interrupt collector function, coded by the user.

The design allows for the simultaneous processing of different interrupts within the same interrupt collector by multiple 
processors of a multiprocessor system, without the need for additional synchronization measures such as Spin-Locks.

The accompanying diagram illustrates the implementation, including the connection of the HxS block to a Wishbone bus leading 
to the CPU or the multiprocessor system. The User Block demonstrates the realization of the interrupt logic. 
Both blocks are scalable in terms of the number of serviced interrupt inputs.

.. figure:: hxs/resources/InterruptCollectorOverview.png
   :scale: 50
   
   Interrupt Collector Overview

Upon the arrival of an interrupt event at an input, an interrupt is triggered to the CPU system. 
This leads to the execution of an interrupt routine by software on exactly one CPU of the system. The routine reads the *Request-Register*
in the interrupt collector, selects one of the reported interrupt requests for processing, and acknowledges 
this by setting the corresponding bit in the Request-Register. 
This interrupt request is then reset in the Request-Register and appears in the *Service-Register*. After completing the tasks in the interrupt 
service routine, the CPU sets to the corresponding bit in the Service-Register, thereby signaling the end of the interrupt routine 
to the interrupt collector. Only from this point can the corresponding Request-Register bit be set again by the same interrupt input.

The actual triggering of an interrupt to the CPU system can be enabled or disabled in the *Mask-Register* for each input. 
After each acknowledged request, the interrupt line to the CPU system is briefly deactivated to allow for the processing 
of further interrupts by other CPUs of the system. 

The priority and synchrony of the individual interrupt inputs can be adjusted by the user in the User-Logic.

Testbench
---------


.. figure:: src/rst/resources/InterruptCollectorTestbench.png
   :scale: 50
   
   Interrupt Collector Testbench


Simulation
----------

General
:::::::

In this article, we focussed on an individual IP component rather than a complete
FPGA design. Consequently, instead of creating a bitstream, we employ GHDL or ModelSim for
simulation purposes. Our IP is simulated using the SimStm framework, a tool we
developed for simulation and testing.

To begin with, we utilize the register description to generate various HxS artifacts,
including the VHDL register interface and its documentation. For this process,
we've set up a Linux environment, specifically using Ubuntu 22.04. The first step
involves installing Ant.

.. code-block:: BASH

  sudo apt-get install ant -y

Next, we clone the actual `interrupt-collector <https://github.com/eccelerators/interrupt-collector>`_
repository:

.. code-block:: BASH

  git clone --recurse-submodules git@github.com:eccelerators/interrupt-collector.git
  
  
HxS sources are now in the hxs folder `hxs folder <https://github.com/eccelerators/interrupt-collector/tree/fill/hxs>`_.

We generate the HxS artifacts if having a valid HxS-license or Evaluation license:

.. code-block:: BASH

  cd interrupt-collector
  ant all
  
Otherwise we use the artifacts already present in the `src-gen folder <https://github.com/eccelerators/interrupt-collector/tree/fill/src-gen>`_


Ghdl
:::::::

Assuming GHDL(4.0.0 or later) is already installed, to simulate the design we run:

.. code-block:: BASH

  cd interrupt-collector/simulation/ghdl-wishbone
  ./run.sh

A successful simulation will yield an output similar to this:

.. code-block:: TEXT

  ...
  
  Core1 currently: Interrupts in total: 0x0360, Source0: 0x0142, Source1: 0xEE, Source2: 0xB3, Source3: 0x7D 
  Core0 currently: Interrupts in total: 0x0380, Source0: 0x013E, Source1: 0xFF, Source2: 0xC0, Source3: 0x83 
  Core1 currently: Interrupts in total: 0x0380, Source0: 0x0142, Source1: 0x0101, Source2: 0xC0, Source3: 0x7D 
 
  Core1 finally: Interrupts in total: 0x0380, Source0: 0x0142, Source1: 0x0101, Source2: 0xC0, Source3: 0x7D 
  Core1: test finished
 
  Core0 finally: Interrupts in total: 0x0380, Source0: 0x013E, Source1: 0xFF, Source2: 0xC0, Source3: 0x83 
 
  Total counts finally: ActualSum: 0x0700, Actual0: 0x0280, Actual1: 0x0200, Actual2: 0x0180, Actual3: 0x0100 
  Total failure count finally: FailureSum: 0x00, Failures0: 0x00, Failures1: 0x00, Failures2: 0x00, Failures3: 0x00 
 
  Core0: Main test finished
 
  ../../../submodules/simstm/src/tb_simstm.vhd:1245:21:@773216100ps:(assertion note): test finished with no errors!!
  ./work/tb_top_wishbone:info: simulation stopped by --stop-time @9990391400ps


ModelSim
:::::::

Assuming ModelSim is already installed, to simulate the design we run:

.. code-block:: BASH

  cd interrupt-collector/simulation/modelsim_wishbone
  ant all
  
Possibly the path to the ModelSim executable may have to be adapted in the ant build.xml file.
  
In the ModelSim window command line section we run:
  
.. code-block:: TEXT

  run -all

Using ModelSim Starter edition it may take up to 5 minutes until the output of a successful simulation 
will yield like this: 


With the setup complete, we are now ready to build all the artifacts required for
simulation:

    ~$ make

The HxS files are located in the `hxs` directory. The VHDL files related to the
IP and its simulation are organized within the following directory structure:

src/vhdl This folder contains the primary VHDL source files for the IP.
src-gen/vhdl Here, you'll find generated VHDL files specific to
  the AXI4-Lite interface.
tb/vhdl This directory houses the VHDL files used for testbenching and
  simulation.

Additionally, the documentation for this IP, generated in various formats, is
located in these folders:

src-gen/docbook-pdf Contains the documentation in PDF format.
src-gen/docbook-html  Holds the HTML version of the documentation (Docbook).
src-gen/html-sphinx  Holds the HTML version of the documentation (Sphinx).
src-gen/rst Stores the reStructuredText (rst) files, typically used for
  more textual documentation.

Hardware/Software interface
---------------------------
  
.. include:: src-gen/rst/Eccelerators.Library.IP.InterruptCollectorIfc-composite.rst
   

Conclusion
----------

Overall, the Interrupt-Collector is a testament to the advanced technological 
strides in the realm of computer hardware, pivotal in crafting more efficient and adaptable 
computing systems. Such innovations are integral to the evolution of high-performance computing 
environments, particularly in sectors like server infrastructures, embedded systems, and intricate data processing units.



