Interrupt-Collector
===================

**Introduction**
----------------

The *Interrupt-Collector*, offered by Eccelerators, is a key IP block (Intellectual Property Block). 
Its main role is to aggregate interrupts from different sources and route them to the interrupt input of a CPU (Central Processing Unit) 
or a multiprocessor system. This functionality is crucial in complex environments where numerous devices or 
processes operate simultaneously, necessitating the CPU's attention.

**Functionality**
-----------------

The distinctiveness of the Interrupt-Collector is evident in the type of interrupt sources it can manage. 
It is specifically designed for level-triggered interrupt sources, meaning the interrupt stays active as long as 
the trigger event or signal condition persists. This is in contrast to edge-triggered sources, which initiate an 
interrupt due to a change in the signal state, like transitioning from low to high or vice versa.

For systems employing edge-triggered sources, Eccelerators presents an additional solution â€“ the *Event-Catcher*. 
This IP block is capable of transforming edge-triggered sources into level-triggered sources, thereby ensuring 
compatibility with the Interrupt-Collector. 

The interrupt collector consists of two parts. The first part, the hardware-software interface, is generated by the Eccelerators Tool HxS. 
It uses the description of the Mask-, Service- and Request, Registers in the HxS language as input. The output is the complete implementation 
of these registers in VHDL, with the necessary inputs and outputs to a user logic block. 
The second part contains the logic of the interrupt collector function, coded by the user.

The design allows for the simultaneous processing of different interrupts within the same interrupt collector by multiple 
processors of a multiprocessor system, without the need for additional synchronization measures such as Spin-Locks.

The accompanying diagram illustrates the implementation, including the connection of the HxS block to a Wishbone bus leading 
to the CPU or the multiprocessor system. The User Block demonstrates the realization of the interrupt logic. 
Both blocks are scalable in terms of the number of serviced interrupt inputs.

.. figure:: hxs/resources/InterruptCollectorOverview.png
   
   Interrupt Collector Overview

Upon the arrival of an interrupt event at an input, an interrupt is triggered to the CPU system. 
This leads to the execution of an interrupt routine by software on exactly one CPU of the system. The routine reads the Request Register 
in the interrupt collector, selects one of the reported interrupt requests for processing, and acknowledges 
this by setting the corresponding bit in the Request Register. 
This interrupt request is then reset in the Request Register and appears in the Service Register. After completing the tasks in the interrupt 
service routine, the CPU writes to the corresponding bit in the Service Register, thereby signaling the end of the interrupt routine 
to the interrupt collector. Only from this point can the corresponding Interrupt Request Register be set again by the same interrupt.

The actual triggering of an interrupt to the CPU system can be enabled or disabled in the Mask Register for each input. 
After each acknowledged request, the interrupt line to the CPU system is briefly deactivated to allow for the processing 
of further interrupts by other CPUs of the system. 

The priority and synchrony of the individual interrupt inputs can be adjusted by the user in the User Logic.

**Testbench**
----------------------------------------------


.. figure:: src/rst/resources/InterruptCollectorTestbench.png
   :scale: 50
   
   Interrupt Collector Testbench


**Simulation**
----------------------------------------------


**Conclusion**
---------------

Overall, the Interrupt-Collector is a testament to the advanced technological 
strides in the realm of computer hardware, pivotal in crafting more efficient and adaptable 
computing systems. Such innovations are integral to the evolution of high-performance computing 
environments, particularly in sectors like server infrastructures, embedded systems, and intricate data processing units.



