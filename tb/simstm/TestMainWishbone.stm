-- ******************************************************************************
-- 
--                   /------o
--             eccelerators
--          o------/
-- 
--  This file is an Eccelerators GmbH sample project.
-- 
--  MIT License:
--  Copyright (c) 2023 Eccelerators GmbH
-- 
--  Permission is hereby granted, free of charge, to any person obtaining a copy
--  of this software and associated documentation files (the "Software"), to deal
--  in the Software without restriction, including without limitation the rights
--  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
--  copies of the Software, and to permit persons to whom the Software is
--  furnished to do so, subject to the following conditions:
-- 
--  The above copyright notice and this permission notice shall be included in all
--  copies or substantial portions of the Software.
-- 
--  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
--  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
--  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
--  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
--  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
--  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
--  SOFTWARE.
-- ******************************************************************************

include "Base/Base.stm"
include "Base/Array.stm"
include "Base/ReadModifyWrite.stm"
include "../../submodules/interrupt-generator/src-gen/simstm/InterruptGeneratorIfc.stm"
include "../../submodules/bus-divider/src-gen/simstm/BusDividerIfc.stm"
include "../../src-gen/simstm/InterruptCollectorIfc.stm"


bus wishbone 0
bus avalon 1
bus axi4lite 2
var WaitTimeOut 10000 -- * 10000 * 10 ms = 100s timeout, loops poll in 10us intervals

signal InGeneratorFailure 0
signal InCoreNumber 1
signal InCrossFromOtherCore 2 -- cross signals for Core sync
signal InCrossInterruptFromOtherCore 3 -- cross interrupts for Core sync
signal InterruptToCpu 4 -- interrupt to be tested to all cores


signal OutCrossToOtherCore 2 -- cross signals for Core sync
signal OutCrossInterruptToOtherCore 3 -- cross interrupts for Core sync

var CoreNumber 0

var InterruptRequests 0
var InterruptRequest0 0
var InterruptRequest1 0
var InterruptRequest2 0
var InterruptRequest3 0
var InterruptCount 0

const ChargedNumberOfInterrupts0 2500
const ChargedNumberOfInterrupts1 2000
const ChargedNumberOfInterrupts2 1500
const ChargedNumberOfInterrupts3 1000

const IntervalNsOfInterrupts0 1000
const IntervalNsOfInterrupts1 1500
const IntervalNsOfInterrupts2 2000
const IntervalNsOfInterrupts3 2500

Main:
proc
	bus pointer copy ReadModifyWriteBus32 wishbone
	bus pointer copy ReadModifyWriteBus16 wishbone
	bus pointer copy ReadModifyWriteBus8 wishbone
	bus pointer copy InterruptCollectorIfcBus wishbone
	bus pointer copy InterruptGeneratorIfcBus wishbone
	
	signal read InCoreNumber CoreNumber
	
	call $InterruptCollectorIfcInit
	
	equ InterruptGeneratorIfcAddress 0x100
	call $InterruptGeneratorIfcInit
	
	verbosity $INFO_5
	trace 0
	wait 1000
	if $CoreNumber = 0
		log message $INFO "Core{}: Main test started" $CoreNumber
		
		bus write InterruptGeneratorIfcBus 32 $ChargedCountReg0Address $ChargedNumberOfInterrupts0
		bus write InterruptGeneratorIfcBus 32 $ChargedCountReg1Address $ChargedNumberOfInterrupts1
		bus write InterruptGeneratorIfcBus 32 $ChargedCountReg2Address $ChargedNumberOfInterrupts2
		bus write InterruptGeneratorIfcBus 32 $ChargedCountReg3Address $ChargedNumberOfInterrupts3
		
		bus write InterruptGeneratorIfcBus 32 $IntervalReg0Address $IntervalNsOfInterrupts0
		bus write InterruptGeneratorIfcBus 32 $IntervalReg1Address $IntervalNsOfInterrupts1
		bus write InterruptGeneratorIfcBus 32 $IntervalReg2Address $IntervalNsOfInterrupts2
		bus write InterruptGeneratorIfcBus 32 $IntervalReg3Address $IntervalNsOfInterrupts3
 
		signal write OutCrossToOtherCore 1
		
        wait 100
        bus write InterruptCollectorIfcBus 32 $InterruptMaskRegAddress 0b1111 -- enable all interrupts		
		bus write InterruptGeneratorIfcBus 32 $ControlRegAddress 0b1111	-- start generation for all interrupts	
	    	
    	call $WaitForGeneratorStatusAllEnded
    	call $WaitForNotRunCrossFromOtherCore 
    			
		log message $INFO "Core{}: Main test finished" $CoreNumber
		wait 1000
		finish
    else
        call $WaitForRunCrossFromOtherCore
        signal write OutCrossToOtherCore 1
              
    	log message $INFO "Core{}: test started" $CoreNumber
    	
    	call $WaitForGeneratorStatusAllEnded
    	
    	signal write OutCrossToOtherCore 0
    
        log message $INFO "Core{}: test finished" $CoreNumber

	end if
end proc

InterruptA:
interrupt
    log message $INFO_5 "Core{}: Interrupt from Generator happened" $CoreNumber
    
    bus read InterruptCollectorIfcBus 32 $InterruptRequestRegAddress InterruptRequests
    
    equ InterruptRequest0 $InterruptRequests
    and InterruptRequest0 0b0001
    equ InterruptRequest1 $InterruptRequests
    and InterruptRequest1 0b0010
    equ InterruptRequest2 $InterruptRequests
    and InterruptRequest2 0b0100
    equ InterruptRequest3 $InterruptRequests
    and InterruptRequest3 0b1000
    
    if $InterruptRequest0 = 0b0001 
    	bus write InterruptCollectorIfcBus 32 $InterruptRequestRegAddress $InterruptRequest0
    	bus read InterruptGeneratorIfcBus 32 $ActualCountReg0Address InterruptCount
    	bus write InterruptGeneratorIfcBus 32 $ReferenceCountReg0Address $InterruptCount
    elsif $InterruptRequest1 = 0b0010 
    	bus write InterruptCollectorIfcBus 32 $InterruptRequestRegAddress $InterruptRequest1
    	bus read InterruptGeneratorIfcBus 32 $ActualCountReg1Address InterruptCount
    	bus write InterruptGeneratorIfcBus 32 $ReferenceCountReg1Address $InterruptCount
    elsif $InterruptRequest2 = 0b0100 
    	bus write InterruptCollectorIfcBus 32 $InterruptRequestRegAddress $InterruptRequest2
    	bus read InterruptGeneratorIfcBus 32 $ActualCountReg2Address InterruptCount
    	bus write InterruptGeneratorIfcBus 32 $ReferenceCountReg2Address $InterruptCount
    elsif $InterruptRequest3 = 0b1000 
    	bus write InterruptCollectorIfcBus 32 $InterruptRequestRegAddress $InterruptRequest3
    	bus read InterruptGeneratorIfcBus 32 $ActualCountReg3Address InterruptCount
    	bus write InterruptGeneratorIfcBus 32 $ReferenceCountReg3Address $InterruptCount
    end if 		
    
end interrupt

InterruptB:
interrupt
    log message $INFO_5 "Core{}: Cross signal interrupt happened" $CoreNumber
end interrupt

var GeneratorStatus 0
WaitForGeneratorStatusAllEnded:
proc
    loop 10000
        wait 100
    	bus read InterruptGeneratorIfcBus 32 $StatusRegAddress GeneratorStatus
		if $GeneratorStatus = 0b10101010
			return
		end if
    end loop
    log message $ERROR "Generator Status All Ended not reached in resonable time !"
    abort
end proc

var RunCrossFromOtherCore 0
WaitForRunCrossFromOtherCore:
proc
    loop 10000
        wait 100
    	signal read InCrossFromOtherCore RunCrossFromOtherCore
    	if $RunCrossFromOtherCore = 1
			return
		end if
    end loop
    log message $ERROR "Run Cross From Other Core not activated in reasonable time !"
    abort
end proc

WaitForNotRunCrossFromOtherCore:
proc
    loop 10000
        wait 100
    	signal read InCrossFromOtherCore RunCrossFromOtherCore
    	if $RunCrossFromOtherCore = 1
			return
		end if
    end loop
    log message $ERROR "Run Cross From Other Core not deactivated in reasonable time !"
    abort
end proc
