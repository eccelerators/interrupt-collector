-- Copyright (C) 2023 Eccelerators GmbH
-- 
-- This code was generated by:
--
-- HxS Compiler 1.0.19-10671667
-- VHDL Extension for HxS 1.0.21-b962bd24
-- 
-- Further information at https://eccelerators.com/hxs
-- 
-- Changes to this file may cause incorrect behavior and will be lost if the
-- code is regenerated.
library ieee;
	use ieee.std_logic_1164.all;
	use ieee.numeric_std.all;

use work.InterruptCollectorIfcPackage.all;

entity InterruptCollectorBlk_InterruptCollectorIfc is
	port (
		Clk : in std_logic;
		Rst : in std_logic;
		ReadMatch : out std_logic;
		ReadAck : out std_logic;
		ReadData : out std_logic_vector(31 downto 0);
		ReadResp : out std_logic_vector(1 downto 0);
		Read : in std_logic;
		ReadAddressMatch : in std_logic;
		ReadAddressProt : in std_logic_vector(2 downto 0);
		ReadAddress : in std_logic_vector(3 downto 0);
		WriteMatch : out std_logic;
		WriteAck : out std_logic;
		WriteResp : out std_logic_vector(1 downto 0);
		Write : in std_logic;
		WriteAddrMatch : in std_logic;
		WriteAddressProt : in std_logic_vector(2 downto 0);
		WriteAddress : in std_logic_vector(3 downto 0);
		WriteData : in std_logic_vector(31 downto 0);
		WriteStrobe : in std_logic_vector(3 downto 0);
		Mask3 : out std_logic;
		Mask2 : out std_logic;
		Mask1 : out std_logic;
		Mask0 : out std_logic;
		Request3ToBeRead : in std_logic;
		Request3Written : out std_logic;
		Request2ToBeRead : in std_logic;
		Request2Written : out std_logic;
		Request1ToBeRead : in std_logic;
		Request1Written : out std_logic;
		Request0ToBeRead : in std_logic;
		Request0Written : out std_logic;
		WTransPulseInterruptRequestReg : out std_logic;
		Service3ToBeRead : in std_logic;
		Service3Written : out std_logic;
		Service2ToBeRead : in std_logic;
		Service2Written : out std_logic;
		Service1ToBeRead : in std_logic;
		Service1Written : out std_logic;
		Service0ToBeRead : in std_logic;
		Service0Written : out std_logic;
		WTransPulseInterruptServiceReg : out std_logic
	);
end;

architecture Behavioural of InterruptCollectorBlk_InterruptCollectorIfc is

	signal PreReadData : std_logic_vector(31 downto 0);
	
	signal PreReadDataInterruptMaskReg : std_logic_vector(31 downto 0);
	signal PreReadAckInterruptMaskReg : std_logic;
	signal ReadDiffInterruptMaskReg : std_logic;
	signal PreWriteAckInterruptMaskReg : std_logic;
	signal WriteDiffInterruptMaskReg : std_logic;
	signal WRegMask3 : std_logic;
	signal WRegMask2 : std_logic;
	signal WRegMask1 : std_logic;
	signal WRegMask0 : std_logic;
	signal PreMatchReadInterruptMaskReg : std_logic;
	signal PreMatchWriteInterruptMaskReg : std_logic;
	
	signal PreReadDataInterruptRequestReg : std_logic_vector(31 downto 0);
	signal PreReadAckInterruptRequestReg : std_logic;
	signal ReadDiffInterruptRequestReg : std_logic;
	signal PreWriteAckInterruptRequestReg : std_logic;
	signal WriteDiffInterruptRequestReg : std_logic;
	signal PreMatchReadInterruptRequestReg : std_logic;
	signal PreMatchWriteInterruptRequestReg : std_logic;
	
	signal PreReadDataInterruptServiceReg : std_logic_vector(31 downto 0);
	signal PreReadAckInterruptServiceReg : std_logic;
	signal ReadDiffInterruptServiceReg : std_logic;
	signal PreWriteAckInterruptServiceReg : std_logic;
	signal WriteDiffInterruptServiceReg : std_logic;
	signal PreMatchReadInterruptServiceReg : std_logic;
	signal PreMatchWriteInterruptServiceReg : std_logic;

begin

	ReadMatch <= PreMatchReadInterruptMaskReg
		  or PreMatchReadInterruptRequestReg
		  or PreMatchReadInterruptServiceReg;
	WriteMatch <= PreMatchWriteInterruptMaskReg
		  or PreMatchWriteInterruptRequestReg
		  or PreMatchWriteInterruptServiceReg;
	
	ReadAck <= PreReadAckInterruptMaskReg
		or PreReadAckInterruptRequestReg
		or PreReadAckInterruptServiceReg;
	
	WriteAck <= PreWriteAckInterruptMaskReg
		or PreWriteAckInterruptRequestReg
		or PreWriteAckInterruptServiceReg;
	
	
	ReadData <= PreReadData;
	
	ReadResp <= (others => '0');
	WriteResp <= (others => '0');
	
	PreDatOutMux: process (
		PreReadDataInterruptMaskReg,
		PreMatchReadInterruptMaskReg,
		PreReadAckInterruptMaskReg,
		PreReadDataInterruptRequestReg,
		PreMatchReadInterruptRequestReg,
		PreReadAckInterruptRequestReg,
		PreReadDataInterruptServiceReg,
		PreMatchReadInterruptServiceReg,
		PreReadAckInterruptServiceReg
	) begin
		PreReadData <= (others => '0');
		if (PreMatchReadInterruptMaskReg = '1' and PreReadAckInterruptMaskReg = '1') then
			PreReadData <= std_logic_vector(resize(unsigned(PreReadDataInterruptMaskReg), PreReadData'LENGTH));
		elsif (PreMatchReadInterruptRequestReg = '1' and PreReadAckInterruptRequestReg = '1') then
			PreReadData <= std_logic_vector(resize(unsigned(PreReadDataInterruptRequestReg), PreReadData'LENGTH));
		elsif (PreMatchReadInterruptServiceReg = '1' and PreReadAckInterruptServiceReg = '1') then
			PreReadData <= std_logic_vector(resize(unsigned(PreReadDataInterruptServiceReg), PreReadData'LENGTH));
		end if;
	end process;
	
	PreMatchReadInterruptMaskRegProcess : process (ReadAddress, ReadAddressMatch)
	begin
		if ((unsigned(ReadAddress)/4)*4 = unsigned(INTERRUPTMASKREG_ADDRESS)) then
			PreMatchReadInterruptMaskReg <= ReadAddressMatch;
		else
			PreMatchReadInterruptMaskReg <= '0';
		end if;
	end process;
	
	PreMatchWriteInterruptMaskRegProcess : process (WriteAddress, WriteAddrMatch)
	begin
		if ((unsigned(WriteAddress)/4)*4 = unsigned(INTERRUPTMASKREG_ADDRESS)) then
			PreMatchWriteInterruptMaskReg <= WriteAddrMatch;
		else
			PreMatchWriteInterruptMaskReg <= '0';
		end if;
	end process;
	
	WriteDiffInterruptMaskRegProcess : process (WriteAddress, Write, PreWriteAckInterruptMaskReg)
	begin
		if ((unsigned(WriteAddress)/4)*4 = unsigned(INTERRUPTMASKREG_ADDRESS)) then
			WriteDiffInterruptMaskReg <=  Write and not PreWriteAckInterruptMaskReg;
		else
			WriteDiffInterruptMaskReg <= '0';
		end if;
	end process;
	
	ReadDiffInterruptMaskRegProcess : process (ReadAddress, Read, PreReadAckInterruptMaskReg)
	begin
		if ((unsigned(ReadAddress)/4)*4 = unsigned(INTERRUPTMASKREG_ADDRESS)) then
			ReadDiffInterruptMaskReg <= Read and not PreReadAckInterruptMaskReg;
		else
			ReadDiffInterruptMaskReg <= '0';
		end if;
	end process;
	
	SyncPartInterruptMaskReg : process (Clk, Rst)
	begin
		if (Rst = '1') then
			PreReadAckInterruptMaskReg <= '0';
			PreWriteAckInterruptMaskReg <= '0';
			WRegMask3 <= MASK3_INTERRUPTDISABLED;
			WRegMask2 <= MASK2_INTERRUPTDISABLED;
			WRegMask1 <= MASK1_INTERRUPTDISABLED;
			WRegMask0 <= MASK0_INTERRUPTDISABLED;
		elsif rising_edge(Clk) then
			PreWriteAckInterruptMaskReg <= WriteDiffInterruptMaskReg;
			PreReadAckInterruptMaskReg <= ReadDiffInterruptMaskReg;
			if (WriteDiffInterruptMaskReg = '1') then
				if (WriteStrobe(0) = '1') then WRegMask0 <= WriteData(0); end if;
				if (WriteStrobe(0) = '1') then WRegMask1 <= WriteData(1); end if;
				if (WriteStrobe(0) = '1') then WRegMask2 <= WriteData(2); end if;
				if (WriteStrobe(0) = '1') then WRegMask3 <= WriteData(3); end if;
			end if;
		end if;
	end process;
	
	DataOutPreMuxForInterruptMaskReg : process (
		WRegMask3,
		WRegMask2,
		WRegMask1,
		WRegMask0
	) begin
		PreReadDataInterruptMaskReg <= (others => '0');
		PreReadDataInterruptMaskReg(3) <= WRegMask3;
		PreReadDataInterruptMaskReg(2) <= WRegMask2;
		PreReadDataInterruptMaskReg(1) <= WRegMask1;
		PreReadDataInterruptMaskReg(0) <= WRegMask0;
	end process;
	
	Mask3 <= WRegMask3;
	Mask2 <= WRegMask2;
	Mask1 <= WRegMask1;
	Mask0 <= WRegMask0;
	
	PreMatchReadInterruptRequestRegProcess : process (ReadAddress, ReadAddressMatch)
	begin
		if ((unsigned(ReadAddress)/4)*4 = unsigned(INTERRUPTREQUESTREG_ADDRESS)) then
			PreMatchReadInterruptRequestReg <= ReadAddressMatch;
		else
			PreMatchReadInterruptRequestReg <= '0';
		end if;
	end process;
	
	PreMatchWriteInterruptRequestRegProcess : process (WriteAddress, WriteAddrMatch)
	begin
		if ((unsigned(WriteAddress)/4)*4 = unsigned(INTERRUPTREQUESTREG_ADDRESS)) then
			PreMatchWriteInterruptRequestReg <= WriteAddrMatch;
		else
			PreMatchWriteInterruptRequestReg <= '0';
		end if;
	end process;
	
	WriteDiffInterruptRequestRegProcess : process (WriteAddress, Write, PreWriteAckInterruptRequestReg)
	begin
		if ((unsigned(WriteAddress)/4)*4 = unsigned(INTERRUPTREQUESTREG_ADDRESS)) then
			WriteDiffInterruptRequestReg <=  Write and not PreWriteAckInterruptRequestReg;
		else
			WriteDiffInterruptRequestReg <= '0';
		end if;
	end process;
	
	ReadDiffInterruptRequestRegProcess : process (ReadAddress, Read, PreReadAckInterruptRequestReg)
	begin
		if ((unsigned(ReadAddress)/4)*4 = unsigned(INTERRUPTREQUESTREG_ADDRESS)) then
			ReadDiffInterruptRequestReg <= Read and not PreReadAckInterruptRequestReg;
		else
			ReadDiffInterruptRequestReg <= '0';
		end if;
	end process;
	
	SyncPartInterruptRequestReg : process (Clk, Rst)
	begin
		if (Rst = '1') then
			PreReadAckInterruptRequestReg <= '0';
			PreWriteAckInterruptRequestReg <= '0';
		elsif rising_edge(Clk) then
			PreWriteAckInterruptRequestReg <= WriteDiffInterruptRequestReg;
			PreReadAckInterruptRequestReg <= ReadDiffInterruptRequestReg;
		end if;
	end process;
	
	DataOutPreMuxForInterruptRequestReg : process (
		Request3ToBeRead,
		Request2ToBeRead,
		Request1ToBeRead,
		Request0ToBeRead
	) begin
		PreReadDataInterruptRequestReg <= (others => '0');
		PreReadDataInterruptRequestReg(3) <= Request3ToBeRead;
		PreReadDataInterruptRequestReg(2) <= Request2ToBeRead;
		PreReadDataInterruptRequestReg(1) <= Request1ToBeRead;
		PreReadDataInterruptRequestReg(0) <= Request0ToBeRead;
	end process;
	
	WTransPulseInterruptRequestReg <= WriteDiffInterruptRequestReg;
	
	Request3Written <= WriteData(3);
	Request2Written <= WriteData(2);
	Request1Written <= WriteData(1);
	Request0Written <= WriteData(0);
	
	PreMatchReadInterruptServiceRegProcess : process (ReadAddress, ReadAddressMatch)
	begin
		if ((unsigned(ReadAddress)/4)*4 = unsigned(INTERRUPTSERVICEREG_ADDRESS)) then
			PreMatchReadInterruptServiceReg <= ReadAddressMatch;
		else
			PreMatchReadInterruptServiceReg <= '0';
		end if;
	end process;
	
	PreMatchWriteInterruptServiceRegProcess : process (WriteAddress, WriteAddrMatch)
	begin
		if ((unsigned(WriteAddress)/4)*4 = unsigned(INTERRUPTSERVICEREG_ADDRESS)) then
			PreMatchWriteInterruptServiceReg <= WriteAddrMatch;
		else
			PreMatchWriteInterruptServiceReg <= '0';
		end if;
	end process;
	
	WriteDiffInterruptServiceRegProcess : process (WriteAddress, Write, PreWriteAckInterruptServiceReg)
	begin
		if ((unsigned(WriteAddress)/4)*4 = unsigned(INTERRUPTSERVICEREG_ADDRESS)) then
			WriteDiffInterruptServiceReg <=  Write and not PreWriteAckInterruptServiceReg;
		else
			WriteDiffInterruptServiceReg <= '0';
		end if;
	end process;
	
	ReadDiffInterruptServiceRegProcess : process (ReadAddress, Read, PreReadAckInterruptServiceReg)
	begin
		if ((unsigned(ReadAddress)/4)*4 = unsigned(INTERRUPTSERVICEREG_ADDRESS)) then
			ReadDiffInterruptServiceReg <= Read and not PreReadAckInterruptServiceReg;
		else
			ReadDiffInterruptServiceReg <= '0';
		end if;
	end process;
	
	SyncPartInterruptServiceReg : process (Clk, Rst)
	begin
		if (Rst = '1') then
			PreReadAckInterruptServiceReg <= '0';
			PreWriteAckInterruptServiceReg <= '0';
		elsif rising_edge(Clk) then
			PreWriteAckInterruptServiceReg <= WriteDiffInterruptServiceReg;
			PreReadAckInterruptServiceReg <= ReadDiffInterruptServiceReg;
		end if;
	end process;
	
	DataOutPreMuxForInterruptServiceReg : process (
		Service3ToBeRead,
		Service2ToBeRead,
		Service1ToBeRead,
		Service0ToBeRead
	) begin
		PreReadDataInterruptServiceReg <= (others => '0');
		PreReadDataInterruptServiceReg(3) <= Service3ToBeRead;
		PreReadDataInterruptServiceReg(2) <= Service2ToBeRead;
		PreReadDataInterruptServiceReg(1) <= Service1ToBeRead;
		PreReadDataInterruptServiceReg(0) <= Service0ToBeRead;
	end process;
	
	WTransPulseInterruptServiceReg <= WriteDiffInterruptServiceReg;
	
	Service3Written <= WriteData(3);
	Service2Written <= WriteData(2);
	Service1Written <= WriteData(1);
	Service0Written <= WriteData(0);
	
end;

library ieee;
	use ieee.std_logic_1164.all;
	use ieee.numeric_std.all;

entity InterruptCollectorIfcAxi4LiteBusController is
	port(
		Clk : in std_logic;
		Rst : in std_logic;
		AWVALID : in std_logic;
		AWADDR : in std_logic_vector(3 downto 0);
		AWPROT : in std_logic_vector(2 downto 0);
		AWREADY : out std_logic;
		WVALID : in std_logic;
		WDATA : in std_logic_vector(31 downto 0);
		WSTRB : in std_logic_vector(3 downto 0);
		WREADY : out std_logic;
		BREADY : in std_logic;
		BVALID : out std_logic;
		BRESP : out std_logic_vector(1 downto 0);
		ARVALID : in std_logic;
		ARADDR : in std_logic_vector(3 downto 0);
		ARPROT : in std_logic_vector(2 downto 0);
		ARREADY : out std_logic;
		RREADY : in std_logic;
		RVALID : out std_logic;
		RDATA : out std_logic_vector(31 downto 0);
		RRESP : out std_logic_vector(1 downto 0);
		WritePrivileged : out std_logic;
		WriteSecure : out std_logic;
		WriteInstruction : out std_logic;
		ReadPrivileged : out std_logic;
		ReadSecure : out std_logic;
		ReadInstruction : out std_logic;
		ReadMatch : in std_logic;
		ReadAck : in std_logic;
		ReadData : in std_logic_vector(31 downto 0);
		ReadResp : in std_logic_vector(1 downto 0);
		Read : out std_logic;
		ReadAddressMatch : out std_logic;
		ReadAddressProt : out std_logic_vector(2 downto 0);
		ReadAddress : out std_logic_vector(3 downto 0);
		WriteMatch : in std_logic;
		WriteAck : in std_logic;
		WriteResp : in std_logic_vector(1 downto 0);
		Write : out std_logic;
		WriteAddrMatch : out std_logic;
		WriteAddressProt : out std_logic_vector(2 downto 0);
		WriteAddress : out std_logic_vector(3 downto 0);
		WriteData : out std_logic_vector(31 downto 0);
		WriteStrobe : out std_logic_vector(3 downto 0);
		UnoccupiedAck : out std_logic;
		TimeoutAck : out std_logic
	);
end;

architecture Behavioural of InterruptCollectorIfcAxi4LiteBusController is

	type T_Axi4LiteWriteState is (
		Axi4LiteWriteStateIdle,
		Axi4LiteWriteStateAddress,
		Axi4LiteWriteStateData,
		Axi4LiteWriteStateResp,
		Axi4LiteWriteStateErrorResp,
		Axi4LiteWriteStateDone
	);

	type T_Axi4LiteReadState is (
		Axi4LiteReadStateIdle,
		Axi4LiteReadStateAddress,
		Axi4LiteReadStateData,
		Axi4LiteReadStateDone
	);

	signal Axi4LiteReadState : T_Axi4LiteReadState;
	signal Axi4LiteWriteState : T_Axi4LiteWriteState;

	signal ReadTimeoutCounter : unsigned(9 downto 0);
	signal WriteTimeoutCounter : unsigned(9 downto 0);

	signal ReadUnoccupiedAck : std_logic;
	signal WriteUnoccupiedAck : std_logic;
	signal ReadTimeoutAck : std_logic;
	signal WriteTimeoutAck : std_logic;
	
	signal ReadProtect : std_logic_vector(2 downto 0);
	signal WriteProtect : std_logic_vector(2 downto 0);

begin

	UnoccupiedAck <= ReadUnoccupiedAck or WriteUnoccupiedAck;
	TimeoutAck <= ReadTimeoutAck or WriteTimeoutAck;

	WritePrivileged <= WriteProtect(0);
	WriteSecure <= WriteProtect(1);
	WriteInstruction <= WriteProtect(2);
	ReadPrivileged <= ReadProtect(0);
	ReadSecure <= ReadProtect(1);
	ReadInstruction <= ReadProtect(2);
	
	WriteAddressProt <= WriteProtect;
	ReadAddressProt <= ReadProtect;

	Axi4LiteRead : process(Clk, Rst) is
	begin
		if Rst = '1' then
			ARREADY <= '0';
			RVALID <= '0';
			RDATA <= (others => '0');
			RRESP <= (others => '0');
			Read <= '0';
			ReadAddressMatch <= '0';
			ReadAddress <= (others => '0');
			ReadProtect <= (others => '0');
			ReadUnoccupiedAck <= '0';
			ReadTimeoutAck <= '0';
			ReadTimeoutCounter <= (others => '1');
			Axi4LiteReadState <= Axi4LiteReadStateIdle;
		elsif rising_edge(Clk) then
			ARREADY <= '0';
			RVALID <= '0';
			case Axi4LiteReadState is
				when Axi4LiteReadStateIdle =>
					ReadUnoccupiedAck <= '0';
					ReadTimeoutAck <= '0';
					ReadTimeoutCounter <= (others => '1');
					Read <= '0';
					ReadAddressMatch <= '0';
					ReadAddress <= (others => '0');
					ReadProtect <= (others => '0');
					if ARVALID = '1' then
						ReadAddress <= ARADDR;
						ReadProtect <= ARPROT;
						ReadAddressMatch <= '1';
						Axi4LiteReadState <= Axi4LiteReadStateAddress;
					end if;
				when Axi4LiteReadStateAddress =>
					ARREADY <= '1';
					Axi4LiteReadState <= Axi4LiteReadStateData;
					if ReadMatch = '1' then
						Read <= '1';
					else
						ReadUnoccupiedAck <= '1';
					end if;
				when Axi4LiteReadStateData =>
					ReadTimeoutCounter <= ReadTimeoutCounter - 1;
					RDATA <= ReadData;
					RRESP <= ReadResp;
					if ReadAck = '1' then
						ReadAddressMatch <= '0';
						RVALID <= '1';
						Axi4LiteReadState <= Axi4LiteReadStateDone;
					end if;
					if ReadUnoccupiedAck = '1' then
						RRESP <= "11";
						RVALID <= '1';
						ReadAddressMatch <= '0';
						Axi4LiteReadState <= Axi4LiteReadStateDone;
					end if;
					if ReadTimeoutCounter = 0 then
						ReadTimeoutAck <= '1';
						RRESP <= "10";
						RVALID <= '1';
						ReadAddressMatch <= '0';
						Axi4LiteReadState <= Axi4LiteReadStateDone;
					end if;
				when Axi4LiteReadStateDone =>
					RVALID <= '1';
					if RREADY = '1' then
						RVALID <= '0';
						ReadAddress <= (others => '0');
						ReadProtect <= (others => '0');
						RRESP <= (others => '0');
						Read <= '0';
						Axi4LiteReadState <= Axi4LiteReadStateIdle;
					end if;
			end case;
		end if;
	end process;

	Axi4LiteWrite : process(Clk, Rst) is
	begin
		if Rst = '1' then
			AWREADY <= '0';
			WREADY <= '0';
			BVALID <= '0';
			BRESP <= (others => '0');
			Write <= '0';
			WriteAddrMatch <= '0';
			WriteAddress <= (others => '0');
			WriteProtect <= (others => '0');
			WriteData <= (others => '0');
			WriteStrobe <= (others => '0');
			WriteUnoccupiedAck <= '0';
			WriteTimeoutAck <= '0';
			WriteTimeoutCounter <= (others => '1');
			Axi4LiteWriteState <= Axi4LiteWriteStateIdle;
		elsif rising_edge(Clk) then
			AWREADY <= '0';
			WREADY <= '0';
			BVALID <= '0';
			case Axi4LiteWriteState is
				when Axi4LiteWriteStateIdle =>
					WriteUnoccupiedAck <= '0';
					WriteTimeoutAck <= '0';
					WriteTimeoutCounter <= (others => '1');
					Write <= '0';
					WriteAddrMatch <= '0';
					WriteAddress <= (others => '0');
					WriteProtect <= (others => '0');
					if AWVALID = '1' then
						WriteAddress <= AWADDR;
						WriteProtect <= AWPROT;
						WriteAddrMatch <= '1';
						Axi4LiteWriteState <= Axi4LiteWriteStateAddress;
					end if;
				when Axi4LiteWriteStateAddress =>
					AWREADY <= '1';
					WREADY <= '1';
					Axi4LiteWriteState <= Axi4LiteWriteStateData;
					if WriteMatch = '0' then
						WriteUnoccupiedAck <= '1';
					end if;
				when Axi4LiteWriteStateData =>
					WREADY <= '1';
					WriteData <= WDATA;
					WriteStrobe <= WSTRB;
					if WVALID = '1' then
						WREADY <= '0';
						if WriteUnoccupiedAck = '0' then
							Write <= '1';
							Axi4LiteWriteState <= Axi4LiteWriteStateResp;
						else
							Axi4LiteWriteState <= Axi4LiteWriteStateErrorResp;
						end if;
					end if;
				when Axi4LiteWriteStateResp =>
					WriteTimeoutCounter <= WriteTimeoutCounter - 1;
					Write <= '1';
					BRESP <= WriteResp;
					if WriteAck = '1' then
						Write <= '0';
						WriteAddrMatch <= '0';
						BVALID <= '1';
						Axi4LiteWriteState <= Axi4LiteWriteStateDone;
					end if;
					if WriteTimeoutCounter = 0 then
						WriteTimeoutAck <= '1';
						Write <= '0';
						WriteAddrMatch <= '0';
						Axi4LiteWriteState <= Axi4LiteWriteStateErrorResp;
					end if;
				when Axi4LiteWriteStateErrorResp =>
					Write <= '0';
					WriteAddrMatch <= '0';
					BVALID <= '1';
					Axi4LiteWriteState <= Axi4LiteWriteStateDone;
					if WriteUnoccupiedAck = '1' then
						BRESP <= "11";
					else
						BRESP <= "10";
					end if;
				when Axi4LiteWriteStateDone =>
					BVALID <= '1';
					if BREADY = '1' then
						WriteAddress <= (others => '0');
						WriteProtect <= (others => '0');
						BVALID <= '0';
						BRESP <= (others => '0');
						Axi4LiteWriteState <= Axi4LiteWriteStateIdle;
					end if;
			end case;
		end if;
	end process;

end;

library ieee;
	use ieee.std_logic_1164.all;
	use ieee.numeric_std.all;

use work.InterruptCollectorIfcPackage.all;

entity InterruptCollectorIfcAxi4Lite is
	port (
		Clk : in std_logic;
		Rst : in std_logic;
		Axi4LiteDown : in T_InterruptCollectorIfcAxi4LiteDown;
		Axi4LiteUp : out T_InterruptCollectorIfcAxi4LiteUp;
		Axi4LiteAccess : out T_InterruptCollectorIfcAxi4LiteAccess;
		Trace : out T_InterruptCollectorIfcTrace;
		InterruptCollectorBlkDown : out T_InterruptCollectorIfcInterruptCollectorBlkDown;
		InterruptCollectorBlkUp : in T_InterruptCollectorIfcInterruptCollectorBlkUp
	);
end;

architecture Behavioural of InterruptCollectorIfcAxi4Lite is

	signal PreAxi4LiteUp : T_InterruptCollectorIfcAxi4LiteUp;
	signal PreAxi4LiteAccess : T_InterruptCollectorIfcAxi4LiteAccess;
	
	signal UnoccupiedAck : std_logic;
	signal TimeoutAck : std_logic;
	
	signal ReadMatch : std_logic;
	signal ReadAck : std_logic;
	signal ReadData : std_logic_vector(31 downto 0);
	signal ReadResp : std_logic_vector(1 downto 0);
	signal Read : std_logic;
	signal ReadAddressMatch : std_logic;
	signal ReadAddressProt : std_logic_vector(2 downto 0);
	signal ReadAddress : std_logic_vector(3 downto 0);
	signal WriteMatch : std_logic;
	signal WriteAck : std_logic;
	signal WriteResp : std_logic_vector(1 downto 0);
	signal Write : std_logic;
	signal WriteAddrMatch : std_logic;
	signal WriteAddressProt : std_logic_vector(2 downto 0);
	signal WriteAddress : std_logic_vector(3 downto 0);
	signal WriteData : std_logic_vector(31 downto 0);
	signal WriteStrobe : std_logic_vector(3 downto 0);
	
	signal InterruptCollectorBlkReadMatch : std_logic;
	signal InterruptCollectorBlkReadAck : std_logic;
	signal InterruptCollectorBlkReadData : std_logic_vector(31 downto 0);
	signal InterruptCollectorBlkReadResp : std_logic_vector(1 downto 0);
	signal InterruptCollectorBlkWriteMatch : std_logic;
	signal InterruptCollectorBlkWriteAck : std_logic;
	signal InterruptCollectorBlkWriteResp : std_logic_vector(1 downto 0);

begin

	i_InterruptCollectorIfcAxi4LiteBusController : entity work.InterruptCollectorIfcAxi4LiteBusController
		port map (
			Clk => Clk,
			Rst => Rst,
			AWVALID => Axi4LiteDown.AWVALID,
			AWADDR => Axi4LiteDown.AWADDR,
			AWPROT => Axi4LiteDown.AWPROT,
			AWREADY => PreAxi4LiteUp.AWREADY,
			WVALID => Axi4LiteDown.WVALID,
			WDATA => Axi4LiteDown.WDATA,
			WSTRB => Axi4LiteDown.WSTRB,
			WREADY => PreAxi4LiteUp.WREADY,
			BREADY => Axi4LiteDown.BREADY,
			BVALID => PreAxi4LiteUp.BVALID,
			BRESP => PreAxi4LiteUp.BRESP,
			ARVALID => Axi4LiteDown.ARVALID,
			ARADDR => Axi4LiteDown.ARADDR,
			ARPROT => Axi4LiteDown.ARPROT,
			ARREADY => PreAxi4LiteUp.ARREADY,
			RREADY => Axi4LiteDown.RREADY,
			RVALID => PreAxi4LiteUp.RVALID,
			RDATA => PreAxi4LiteUp.RDATA,
			RRESP => PreAxi4LiteUp.RRESP,
			WritePrivileged => PreAxi4LiteAccess.WritePrivileged,
			WriteSecure => PreAxi4LiteAccess.WriteSecure,
			WriteInstruction => PreAxi4LiteAccess.WriteInstruction,
			ReadPrivileged => PreAxi4LiteAccess.ReadPrivileged,
			ReadSecure => PreAxi4LiteAccess.ReadSecure,
			ReadInstruction => PreAxi4LiteAccess.ReadInstruction,
			ReadMatch => ReadMatch,
			ReadAck => ReadAck,
			ReadData => ReadData,
			ReadResp => ReadResp,
			Read => Read,
			ReadAddressMatch => ReadAddressMatch,
			ReadAddressProt => ReadAddressProt,
			ReadAddress => ReadAddress,
			WriteMatch => WriteMatch,
			WriteAck => WriteAck,
			WriteResp => WriteResp,
			Write => Write,
			WriteAddrMatch => WriteAddrMatch,
			WriteAddressProt => WriteAddressProt,
			WriteAddress => WriteAddress,
			WriteData => WriteData,
			WriteStrobe => WriteStrobe,
			UnoccupiedAck => UnoccupiedAck,
			TimeoutAck => TimeoutAck
		);
	
	i_InterruptCollectorBlk_InterruptCollectorIfc : entity work.InterruptCollectorBlk_InterruptCollectorIfc
		port map (
			Clk => Clk,
			Rst => Rst,
			ReadMatch => InterruptCollectorBlkReadMatch,
			ReadAck => InterruptCollectorBlkReadAck,
			ReadData => InterruptCollectorBlkReadData,
			ReadResp => InterruptCollectorBlkReadResp,
			Read => Read,
			ReadAddressMatch => ReadAddressMatch,
			ReadAddressProt => ReadAddressProt,
			ReadAddress => ReadAddress,
			WriteMatch => InterruptCollectorBlkWriteMatch,
			WriteAck => InterruptCollectorBlkWriteAck,
			WriteResp => InterruptCollectorBlkWriteResp,
			Write => Write,
			WriteAddrMatch => WriteAddrMatch,
			WriteAddressProt => WriteAddressProt,
			WriteAddress => WriteAddress,
			WriteData => WriteData,
			WriteStrobe => WriteStrobe,
			Mask3 => InterruptCollectorBlkDown.Mask3,
			Mask2 => InterruptCollectorBlkDown.Mask2,
			Mask1 => InterruptCollectorBlkDown.Mask1,
			Mask0 => InterruptCollectorBlkDown.Mask0,
			Request3ToBeRead => InterruptCollectorBlkUp.Request3ToBeRead,
			Request3Written => InterruptCollectorBlkDown.Request3Written,
			Request2ToBeRead => InterruptCollectorBlkUp.Request2ToBeRead,
			Request2Written => InterruptCollectorBlkDown.Request2Written,
			Request1ToBeRead => InterruptCollectorBlkUp.Request1ToBeRead,
			Request1Written => InterruptCollectorBlkDown.Request1Written,
			Request0ToBeRead => InterruptCollectorBlkUp.Request0ToBeRead,
			Request0Written => InterruptCollectorBlkDown.Request0Written,
			WTransPulseInterruptRequestReg => InterruptCollectorBlkDown.WTransPulseInterruptRequestReg,
			Service3ToBeRead => InterruptCollectorBlkUp.Service3ToBeRead,
			Service3Written => InterruptCollectorBlkDown.Service3Written,
			Service2ToBeRead => InterruptCollectorBlkUp.Service2ToBeRead,
			Service2Written => InterruptCollectorBlkDown.Service2Written,
			Service1ToBeRead => InterruptCollectorBlkUp.Service1ToBeRead,
			Service1Written => InterruptCollectorBlkDown.Service1Written,
			Service0ToBeRead => InterruptCollectorBlkUp.Service0ToBeRead,
			Service0Written => InterruptCollectorBlkDown.Service0Written,
			WTransPulseInterruptServiceReg => InterruptCollectorBlkDown.WTransPulseInterruptServiceReg
		);
	
	Axi4LiteUp <= PreAxi4LiteUp;
	Axi4LiteAccess <= PreAxi4LiteAccess;
	
	Trace.Axi4LiteDown <= Axi4LiteDown;
	Trace.Axi4LiteUp <= PreAxi4LiteUp;
	Trace.Axi4LiteAccess <= PreAxi4LiteAccess;
	Trace.UnoccupiedAck <= UnoccupiedAck;
	Trace.TimeoutAck <= TimeoutAck;
	
	ReadMatch <= InterruptCollectorBlkReadMatch;
	ReadAck <= InterruptCollectorBlkReadAck;
	ReadResp <= InterruptCollectorBlkReadResp;
	ReadData <= InterruptCollectorBlkReadData;
	WriteMatch <= InterruptCollectorBlkWriteMatch;
	WriteAck <= InterruptCollectorBlkWriteAck;
	WriteResp <= InterruptCollectorBlkWriteResp;

end;
